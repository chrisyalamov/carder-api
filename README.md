# Carder

> **Christian Ivaylov Yalamov**  
> 20041596

> 5Z6Z1005_2425_1F

## Introduction

Carder is an audience engagement platform aimed at business events, conferences, and exhibitions. 

## Architecture

This project is made up of:
- **Frontend**: A React-based SPA (Single Page Application), built using the TanStack Router framework and bundled with Vite.
- **Database**: A PostgreSQL database.
- **Backend**: An RPC-style API built with Hono.js. The API runs on Deno (a modern JavaScript and TypeScript runtime) and is written in TypeScript to ensure type safety and maintainability.
    - **Core Auth and Identity Service (CAIS)**: This is a service that is part of the backend and deals with authentication, user identity, and access control.

## Access Control Model

The project has a policy-based security model, which means that all access to resources is controlled by policies that define who can access what. This is combined with RBAC (Role-Based Access Control) to provide flexibility to how users manage access to resources.

- **Policy** is a rule that either ALLOWS or DENIES a particular action on a resource, to a particular user or role

    > *Example*:
    > `ALLOW` **JohnDoe** to perform action `manage_organisation` on `Manchester Metropolitan University`

- **Role** is simply a label that can be assigned to a user  

    > Roles can make it easier to manage permissions, particularly in larger organisations.  
    > *Example*:
    >   
    > 1.   You `ALLOW` the user **JohnDoe** the `manage_organisation` and 
    >     `manage_licenses` actions on 'Manchester Metropolitan University'
    > 2.   **JohnDoe** leaves the organisation
    > 3.   You now have to manually reassign all permissions to his replacement, **JaneDoe** 👎
    >  
    > Instead, you can create a role called `OrgAdmin_ManchesterMetropolitanUniversity` 
    > and assign it to **JohnDoe**.
    > 
    > You would then assign all permissions to the role, rather than the user.
    >
    > This way, when **JohnDoe** leaves, you can simply reassign the role to 
    > **JaneDoe** and she will have all the same permissions as **JohnDoe** 👍

### Policy evaluation
When a user is attempting to perform an action that requires authorization, the system will retrieve all relevant policies (that relate to the action being attempted, on the requested resource, linked to the particular user, or any of the roles they hold).

These policies will then be evaluated according to the following rules:
1. If **ANY** `DENY` policy is found, the action is denied.
2. Otherwise, if an `ALLOW` policy is found, the action is allowed.
3. If no policies are found, the action is denied by default.

## Project structure

### `/db` Database utilities

This project uses an ORM (Object-Relational Mapping) to interact with the database. The ORM used is called Drizzle-ORM. 

`/db/schema` contains files which describe the shape of the different entities (tables) stored in the database.

`/db/migrations` contains SQL migration files which implement the database schema. These are automatically generated by DrizzleKit.

`/db/validators` defines **zod validators**. Zod is a TypeScript library for validating the shape of data at runtime. The `validators` directory contains validators based on the schema of each entity, which can be used in other parts of the codebase to validate data before it is sent to the database. 

Typically, three validators are created for each entity:
- **Query**: Used to infer the type of the data that will be returned by the database
- **Insert** and **Update**: Used to make sure that objects being inserted into the database conform to the schema, and do not define any forbidden properties. For instance, an `Insert` validator will not allow the `id` property to be set, as this is automatically generated.

### `/main.ts` API entrypoint

### `/routes` API endpoints

## Polymorphic associations

There are instances in this project, where an entity may have a relationship with multiple other entities. This is particularly true when it comes to licensing and access control.

For instance, a `Policy` may apply to a `USER`, a `ROLE`.

A `License` may be assigned to an `AttendeeEnrolment` (a single user attending an event); or it may be assigned to a `Delegation` (an exhibitor at an event).

Expressing such relationships in a relational database (especially compared to other database systems, like graph databases) can be tricky, since a Foreign Key can only be linked to a single record. Generally, there are several accepted approaches to implementing polymorphic associations in a relational database:

- **Wide-table**: Creating a column for each possible association type:
    > | ...other fields | Entity1ID | Entity2ID | Entity3ID |
    > |-----------------|-----------|-----------|-----------|
    > | ...             | **123**   | *[NULL]*  | *[NULL]*  |
    > | ...             | *[NULL]*  | **456**   | *[NULL]*  |
    > | ...             | *[NULL]*  | *[NULL]*  | **789**   |

    This approach maintains referential integrity, since the database can enforce foreign key constraints on each column. However, it is not very flexible, since adding a new association type requires modifying the table schema. 

    The 'width' of the resulting table can also cause issues: the larger number of columns may require more indexes, which take up space and can slow down INSERT and UPDATE operations. The impact of this is more pronounced when the number of possible association types is large.

- **Discriminator field**: adding an additional field, which indicates the table to which the relationship is directed:

    > | ...other fields | Discriminator | EntityID  |
    > |-----------------|---------------|-----------|
    > | *               | Entity1       | **123**   |
    > | *               | Entity2       | **456**   |

    Expressing a relationship this way is more flexible, and more efficient. However, it (typically) does not ensure referential integrity at the database level. 

    Instead, checks are performed either:
    - at the application level (what Carder does), or
    - using database triggers

    > This is the approach used for the relationship between
    > policies and resources:
    > 
    > ```
    >                       ┌  ORGANISATION
    >                       ├  USER
    > POLICY ── (ANY OF) ───├  LICENSE
    >                       ├  LICENSE ASSIGNMENT
    >                       ├  DELEGATION
    >                       └  ... OTHER ENTITIES
    > ```
    > which is expressed as:  
    >   
    > | ...other fields | Discriminator | ResourceId  |
    > |-----------------|---------------|-------------|
    > | *               | Organisation  | **123**     |
    > | *               | License       | **456**     |

    Having a discriminator field can also be useful when combined with the wide-table approach, since it can help to simplify queries and make records more explicit.

    > This is the approach used for the relationship between
    > policies and users/roles:
    > 
    > ```
    >                       ┌  USER
    > POLICY ── (EITHER) ───│
    >                       └  ROLE
    > ```
    > which is expressed as:  
    >   
    > | ...other fields | Discriminator | UserId   | RoleId   |
    > |-----------------|---------------|----------|----------|
    > | *               | User          | **123**  | *[NULL]* |
    > | *               | Role          | *[NULL]* | **456**  |

    > 

